---
title: "Example: National Ambulatory Medical Care Survey (NAMCS) tables"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Example-National-Ambulatory-Medical-Care-Survey-NAMCS-tables}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE
  # , comment = "#>"
)
```

This example uses the National Ambulatory Medical Care Survey (NAMCS) 2019 Public Use File (PUF) to replicate certain tables from the [National Ambulatory Medical Care Survey: 2019 National Summary Tables](https://www.cdc.gov/nchs/data/ahcd/namcs_summary/2019-namcs-web-tables-508.pdf). NAMCS is "an annual nationally representative sample survey of visits to nonfederal office-based patient care physicians, excluding anesthesiologists, radiologists, and pathologists." Note that the unit of observation is visits, not patients – this distinction is important since a single patient can make multiple visits.

Selected variables from NAMCS 2019 come with the `surveytable` package, in an object called `vars2019`. Alternatively, if you have installed the `nchsdata` package, to access the full NAMCS 2019, use `nchsdata::namcs2019`.

To make the below code more reusable, we'll call the survey by a generic name, namely, `mysurvey`.

# Begin

Begin by loading the `surveytable` package. When you do, it will print a message explaining how to specify the survey that you'd like to analyze. We are omitting that message here. 

```{r, results=FALSE, message=FALSE, warning=FALSE}
library(surveytable)
```

Now, specify the survey that you'd like to analyze.

```{r, results='asis'}
mysurvey = vars2019
# Or, if nchsdata has been installed, 
# mysurvey = nchsdata::namcs2019
set_survey("mysurvey")
```

Check the survey name, survey design variables, and the number of observations to verify that it all looks correct.

# Table 1

## Counts and percentages

This table shows the overall estimated count as well as the counts and percentages by type of doctor, physician specialty, and metropolitan statistical area. 

The variables that are necessary for creating this table are already in the survey, making the commands very straightforward. 

```{r, results='asis'}
total()
tab("MDDO", "SPECCAT", "MSA")
```

## Rates

The table also shows several rates. To calculate rates, we need another source of information with population estimates. You would typically use a function like `read.csv()` to load the population estimates and get them into the correct format. The `surveytable` package comes with an object called `uspop2019` that contains several population estimates for use in these examples.

```{r}
class(uspop2019)
names(uspop2019)
```

Here is the overall population estimate:
```{r}
uspop2019$total
```

Once we have the overall population estimate, the overall rate is:
```{r, results='asis'}
total_rate(uspop2019$total)
```

Each survey design object has an element called `variables`, which is a data frame that contains the survey variables. Let's examine the levels of `MSA`.

```{r}
levels(mysurvey$variables$MSA)
```

To calculate the rates, we need to provide a data frame with a variable called `Level` that matches the levels of the variable in the survey. `Population` gives the population estimate.

```{r}
uspop2019$MSA
```

Now that we have the appropriate population estimates:
```{r, results='asis'}
tab_rate("MSA", uspop2019$MSA)
```

We can also calculate rates based on the entire population.
```{r, results='asis'}
tab_rate("MDDO", uspop2019$total)
tab_rate("SPECCAT", uspop2019$total)
```

# Table 3

## Counts and percentages

This table presents estimates for each age group, as well as for each age group by sex. 

```{r, results='asis'}
var_list("age")
```

The survey has a couple of relevant age-related variables. `AGE` is the patient age in years. `AGER` is a categorical variable based on `AGE`. However, for this table, in addition to `AGER`, we need an additional variable, with different age categories. 

Each survey design object has an element called `variables`, which is a data frame that contains the survey variables. **We can add variables to this data frame.** We will create a new age recode, and add it to `mysurvey$variables`.

```{r}
mysurvey$variables$`Another age recode` = cut(mysurvey$variables$AGE
              , breaks = c(-Inf, 0, 4, 14, 64, Inf)
              , labels = c("Under 1", "1-4", "5-14", "15-64", "65 and over") )
```

Note:

* We're using `cut()`, the standard way of creating a factor variable from a numeric variable.
* **The survey variables are located in a data frame called `variables` inside the survey object.**
* We're using backticks with variable names that include special characters, such as spaces.

Now that we've created the `Another age recode` variable, we can create the tables:

```{r, results='asis'}
tab("AGER", "Another age recode", "SEX")
tab_cross("AGER", "SEX")
```

## Rates

```{r, results='asis'}
tab_rate("AGER", uspop2019$AGER)
tab_rate("Another age recode", uspop2019$`Another age recode`)
tab_rate("SEX", uspop2019$SEX)
```

To calculate the rates for one variable (`AGER`) by another variable (`SEX`), we need population estimates in the following format:
```{r}
uspop2019$`AGER x SEX`
```

Once we have these population estimates, the rates are: 
```{r, results='asis'}
tab_subset_rate("AGER", "SEX", uspop2019$`AGER x SEX`)
```

# Table 5

This table gives the expected sources of payment. We use the `PAY*` variables to create several new variables that are required by the table. Note that the `PAY*` variables are logical (`TRUE` or `FALSE`), which simplifies the syntax. (The survey was imported into R using the `importsurvey` package, which automatically detects binary variables.)

```{r}
mysurvey$variables = within(mysurvey$variables, {
  `Medicare and Medicaid` = PAYMCARE & PAYMCAID
  `Unknown or blank` = PAYDK | (NOPAY == "No categories marked")
  bool.nop = !( PAYPRIV | PAYMCARE | PAYMCAID | PAYWKCMP
                | PAYOTH | PAYDK)
  `Self-pay (real)` = PAYSELF & bool.nop
  `No charge (real)` = PAYNOCHG & bool.nop
  `No insurance` = `Self-pay (real)` | `No charge (real)`
})
```

Notes:

* We're using the `within()` function to simplify the syntax.
* `bool.nop` = No payment was used, such as private, Medicare, etc.
* `Self-pay (real)` = self-pay was used AND no other payment was used.

```{r, results='asis'}
tab("PAYPRIV", "PAYMCARE", "PAYMCAID", "Medicare and Medicaid"
    , "No insurance", "Self-pay (real)", "No charge (real)"
    , "PAYWKCMP", "PAYOTH", "Unknown or blank")
```

Check the presentation standards flags! Under NCHS presentation standards rules, some of these estimates should not be shown.

# Table 6

This table shows the primary care provider and referral status, by prior-visit status.

In the table, the "Unknown" and "Blank" values are collapsed into a single value. We can collapse two or more levels of a factor into a single level using the `forcats::fct_collapse` function.

```{r}
mysurvey$variables$PRIMCARE = forcats::fct_collapse(mysurvey$variables$PRIMCARE
    , `Unknown if PCP` = c("Unknown", "Blank"))
mysurvey$variables$REFER = forcats::fct_collapse(mysurvey$variables$REFER
    , `Unknown if referred` = c("Unknown", "Blank"))
```

Now, for the table:

```{r, results='asis'}
tab("PRIMCARE", "REFER", "SENBEFOR")
```

The percentages within each subset that is defined by `SENBEFOR` add up to 100% -- for this reason, we want to use `tab_subset()`, not `tab_cross()`.

```{r, results='asis'}
tab_subset("PRIMCARE", "SENBEFOR")
tab_subset("REFER", "SENBEFOR")
```

# Table 11

This table shows the same information as Table 3, but only for preventive care visits. That is, estimates for each age group, as well as for each age group by sex, but only for preventive care visits.

The variable `Another age recode` has already been created in a previous example. Cross `AGER` and `SEX` to create a variable called `Age x Sex`: 

```{r}
var_cross("Age x Sex", "AGER", "SEX")
```

To see the possible values of `MAJOR` (Major reason for this visit), and to estimate the total count for preventive care visits:

```{r, results='asis'}
tab("MAJOR")
```

To create the tables of age, sex, and their interaction, and limit them to only the preventive care visits:

```{r, results='asis'}
tab_subset("AGER", "MAJOR", "Preventive care")
tab_subset("Another age recode", "MAJOR", "Preventive care")
tab_subset("SEX", "MAJOR", "Preventive care")
tab_subset("Age x Sex", "MAJOR", "Preventive care")
```

As each of the above commands is similar, and differs only in the first variable that is passed to the `tab_subset()` function, this code can be streamlined with a `for` loop:

```{r, results='asis'}
for (vr in c("AGER", "Another age recode", "SEX", "Age x Sex")) {
	tab_subset(vr, "MAJOR", "Preventive care")
}
```

## More advanced coding

In addition, for each age-sex category, the published table shows the percentage of preventive care visits made to primary care physicians. 

To calculate these percentages, a slightly more involved `for` loop is needed. Below is the code, followed by an explanation:

```{r, results=FALSE, message=FALSE, warning=FALSE}
set_output(csv = "out.csv", screen = FALSE)
```

```{r}
for (vr in c("AGER", "Another age recode", "SEX", "Age x Sex")) {
	var_cross("tmp", "MAJOR", vr)
	for (lvl in levels(mysurvey$variables[,vr])) {
		tab_subset("SPECCAT", "tmp", paste0("Preventive care : ", lvl))
	}
}
set_output(csv = "", screen = TRUE)
```

```{r, echo=FALSE}
unlink("out.csv")
```

* Since so many tables are being produced, the output is sent to a CSV file, and is not printed to the screen. 
* As before, the loop goes through the age, sex, and age / sex interaction variables, calling each of these variables `vr`. 
* MAJOR and `vr` are crossed, with the result stored in a variable called `tmp`.
* Next, the inner loop goes through all levels of `vr`, calling each of these levels `lvl`. 
* The code tabulates `SPECCAT` (Type of specialty – Primary, Medical, Surgical) on a subset in which `tmp` (which is `MAJOR` crossed with `vr`) is restricted to “Preventive care:” followed by `lvl`, which is some level of `vr`, such as “Under 15 years” for `AGER`. 
* Finally, CSV output is turned off, and screen output is turned back on. 

If you run this code, all of the tables should be stored in the CSV file. To give you an idea of what the tables should look like, here is just one of the tables:

```{r, results='asis'}
vr = "AGER"
var_cross("tmp", "MAJOR", vr)
lvl = levels(mysurvey$variables[,vr])[1]
tab_subset("SPECCAT", "tmp", paste0("Preventive care : ", lvl))
```

To match the percentage in the published table, see the "Primary care specialty" row. Be sure to check the presentation standards flags.
