---
title: "Example: National Ambulatory Medical Care Survey (NAMCS) report"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Example: National Ambulatory Medical Care Survey (NAMCS) report}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This example uses the National Ambulatory Medical Care Survey (NAMCS) 2019 Public Use File (PUF) to replicate the estimates from a report called [Characteristics of Office-based Physician Visits by Age, 2019](https://www.cdc.gov/nchs/data/nhsr/nhsr184.pdf). NAMCS is "an annual nationally representative sample survey of visits to nonfederal office-based patient care physicians, excluding anesthesiologists, radiologists, and pathologists." Note that the unit of observation is visits, not patients â€“ this distinction is important since a single patient can make multiple visits. 

The survey is available in the `nchsdata` package. To make the below code more reusable, we'll call the survey by a generic name, namely, `mysurvey`. 

To calculate rates, in addition to the survey, we need a source of information with population estimates. You would typically use a function such as `read.csv()` to load the population estimates and get them into the correct format. The `surveytable` package comes with an object called `uspop2019` that contains several population estimates for use in these examples.

# Begin

Begin by loading the `surveytable` package. When you do, it will print a message explaining how to specify the survey that you'd like to analyze. We are omitting that message here. 

```{r, results=FALSE, message=FALSE, warning=FALSE}
library(surveytable)
```

Now, specify the survey that you'd like to analyze.

```{r}
mysurvey = nchsdata::namcs2019
set_survey("mysurvey")
```

Check the survey name, survey design variables, and the number of observations to verify that it all looks correct.

# Figure 1 and Table 1

This figure and table show the rate of visits, overall, by age group, and by sex.

First, let's convert the numeric variable `AGE` into a categorical variable with the categories that are used in the figure. Converting a numeric variable to a categorical variable is done with the `var_cut` function. 

```{r}
var_cut("Age group 5", "AGE"
        , c(-Inf, 0, 17, 44, 64, Inf)
        , c("Under 1", "1-17", "18-44", "45-64", "65 and over"))
```

Given the population estimates that are available in `uspop2019`, calculate the rates:

```{r, results='asis'}
total_rate(uspop2019$total)
tab_rate("Age group 5", uspop2019$`Age group 5`)
tab_rate("SEX", uspop2019$SEX)
```

# Figure 2 and Table 2

The figure shows the distribution of primary expected source of payment, and tests whether any of the pairs of percentages are equal. The table shows the same info by age group.

First, let's examine the levels of `PAYTYPER` (Type of payment). Recall that survey design objects have an element called `variables`, which is a data frame that contains the survey variables.

```{r}
levels(mysurvey$variables$PAYTYPER)
```

In the published figure, "Self-pay" and "No charge/Charity" have been combined into a category called "No insurance". Additionally, some categories are not shown in the published figure, which we will combine into a category called "etc". Let's combine the categories:

```{r}
var_collapse("PAYTYPER", "No insurance"
             , c("Self-pay", "No charge/Charity"))
var_collapse("PAYTYPER", "etc"
             , c("All sources of payment are blank", "Unknown"
              , "Worker's compensation", "Other") )
```

Now, tabulate this variable, testing equality of levels:

```{r, results='asis'}
tab("PAYTYPER", test = TRUE)
```

We can ignore results for the "etc" category, since it's not shown in the figure. Note that there are presentation flags for the "No insurance" category. The second table indicates that all differences are statistically significant. 

To replicate the table, we need a variable of age categories -- but these categories are different from the ones created above. Thus, create another age category variable, then tabulate subsets:

```{r, results='asis'}
var_cut("Age group", "AGE"
        , c(-Inf, 17, 64, Inf)
        , c("Under 18", "18-64", "65 and over"))
tab_subset("PAYTYPER", "Age group")
```

Again, note the presentation flags. Some of the flags are concerned with counts -- since the published table does not show counts, these are not relevant. However, for the 18-64 age group, the "No insurance" category is flagged. 

# Figure 3 and Table 3

This figure shows the major reason for visit. While the data system has a variable called `MAJOR` (Major reason for this visit), that is not exactly the variable that is shown in the figure. Rather, the variable that is shown in the figure has been constructed from two variables: `MAJOR` and `INJURY` (Is visit related to an injury/trauma, ...). Specifically, if the visit is an injury visit (as indicated by `INJURY`), then the figure counts it as such. Otherwise, if it is not an injury visit, the figure counts it according to the value of `MAJOR`. In addition, the figure collapses some of the levels of `MAJOR`.

Let's begin by collapsing these levels of `MAJOR`, to match the figure:

```{r}
levels(mysurvey$variables$MAJOR)
var_collapse("MAJOR", "Pre- and postsurgery"
              , c("Pre-surgery", "Post-surgery"))
var_collapse("MAJOR", "Chronic"
              , c("Chronic problem, routine", "Chronic problem, flare-up")) 
```

Create a new variable, called `Reason`. Initialize it to `NA`. Copy over all values of `MAJOR` to `Reason` other than "Blank" -- when `MAJOR` is "Blank", `Reason` becomes `NA`. Since we'll be combining two factor variables, an easy solution is to convert to character here, and then convert back to factor later. 

```{r}
idx = which( mysurvey$variables$MAJOR != "Blank" )
mysurvey$variables$Reason[idx] = as.character( mysurvey$variables$MAJOR[idx] )
```

Now, let's incorporate the `INJURY` variable. **Order matters!** We first added `MAJOR`, **then** `INJURY`. Since `INJURY` is added second, it trumps any value of `MAJOR`. This is what we want. 

```{r}
levels(mysurvey$variables$INJURY)
idx = which(mysurvey$variables$INJURY == "Yes")
mysurvey$variables$Reason[idx] = "Injury"

mysurvey$variables$Reason = as.factor(mysurvey$variables$Reason)
```

Since the figure is based on knowns only, use the `drop_na` argument to ignore missing values (`NA`):

```{r, results='asis'}
tab("Reason", drop_na = TRUE, test = TRUE)
```

The table shows the same information, by age group:

```{r, results='asis'}
tab_subset("Reason", "Age group", drop_na = TRUE)
```

# Figure 4 and Table 4

The figure shows the percentage of visits by selected services ordered or provided (not mutually exclusive). The table shows this information by age. 

**Laboratory tests.** The survey has several binary variables indicating whether a certain laboratory test was ordered or provided. If any of these variables are `TRUE`, then it counts as a laboratory test visit. 

```{r, results='asis'}
var_list("bmp")
var_list("cbc")
```

To create a variable that is `TRUE` if any variable in a list is `TRUE`, use the `var_any` function:

```{r, results='asis'}
var_any("Laboratory tests"
  , c("BMP", "CBC", "CHLAMYD", "CMP", "CREAT", "BLDCX", "TRTCX"
      , "URNCX", "OTHCX", "GLUCOSE", "GCT", "HGBA", "HEPTEST"
      , "HIVTEST", "HPVDNA", "CHOLEST", "HEPATIC", "PAP"
      , "PREGTEST", "PSA", "STREP", "THYROID", "URINE", "VITD"))
tab("Laboratory tests")
```

**Other variables.** Three other variables in the figure follow the same logic. Let's create and tabulate them now. 

```{r, results='asis'}
var_any("Health education"
  , c("ETOHED", "ASTHMAED", "ASTHMAP", "DIAEDUC", "DIETNUTR", "EXERCISE"
      ,"FAMPLAN", "GENETIC", "GRWTHDEV", "INJPREV", "STDPREV", "STRESMGT"
      , "SUBSTED", "TOBACED", "WTREDUC"))
tab("Health education")

var_any("Imaging services"
  , c("ANYIMAGE", "BONEDENS", "CATSCAN", "ECHOCARD", "OTHULTRA", "MAMMO"
      , "MRI", "XRAY", "OTHIMAGE") )
tab("Imaging services")

var_any("Procedures"
  , c("AUDIO", "BIOPSY", "CARDIAC", "COLON", "CRYO", "EKG", "EEG",
      "EMG", "EXCISION", "FETAL", "PEAK", "SIGMOID", "SPIRO", "TONO",
      "TBTEST", "EGD"))
tab("Procedures")
```

**Examinations and screenings.** `Examinations and screenings` is a little bit more involved. As with the variables above, it is `TRUE` if any of a number of variables are `TRUE`. However, it is also `TRUE` in another situation.

There are five `DIAGx.unformatted` variables that contain diagnosis codes. Here they are:

```{r, results='asis'}
var_list("diag")
```

If any of these diagnosis codes begins with either "Z0" or "Z1", then `Examinations and screenings` is also `TRUE`. 

To begin, let's create logical variables that are true if the diagnosis codes begin with either "Z0" or "Z1":

```{r}
for (ii in 1:5) {
  vr = paste0("DIAG", ii, ".unformatted")
  newvr = paste0("Z_DIAG", ii)
  mysurvey$variables[,newvr] = (
    startsWith(mysurvey$variables[,vr], "Z0")
    | startsWith(mysurvey$variables[,vr], "Z1"))
}
```

Now, we can use `var_any` with the list of variables from the original survey, plus the variables that we just created:

```{r, results='asis'}
var_any("Examinations and screenings"
  # Variables from the original survey
  , c("ETOH", "BREAST", "DEPRESS", "DVS", "FOOT", "NEURO"
    , "PELVIC", "RECTAL", "RETINAL", "SKIN", "SUBST"
  # Newly created variables  
    , "Z_DIAG1", "Z_DIAG2", "Z_DIAG3", "Z_DIAG4", "Z_DIAG5"))
tab("Examinations and screenings")
```

**Table.** The published table shows all of the above by age. Because so many tables are created, let's send them to a CSV file instead of the screen:

```{r, results=FALSE, message=FALSE, warning=FALSE}
set_output(csv = "out.csv", screen = FALSE)
```

```{r}
for (vr in c("Laboratory tests", "Health education", "Imaging services"
  , "Procedures", "Examinations and screenings")) {
  tab_subset(vr, "Age group")
}
set_output(csv = "", screen = TRUE)
```

```{r, echo=FALSE}
unlink("out.csv")
```
